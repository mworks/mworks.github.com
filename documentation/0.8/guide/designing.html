

<!doctype html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Designing an Experiment &#8212; MWorks 0.8.dev documentation</title>
    <link rel="stylesheet" href="../_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Reference Manual" href="../reference/index.html" />
    <link rel="prev" title="Analyzing Experimental Data" href="data_analysis.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script type="text/javascript" src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../reference/index.html" title="Reference Manual"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="data_analysis.html" title="Analyzing Experimental Data"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">MWorks 0.8.dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">User Guide</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Designing an Experiment</a><ul>
<li><a class="reference internal" href="#data-flow">Data Flow</a><ul>
<li><a class="reference internal" href="#variables">Variables</a></li>
<li><a class="reference internal" href="#i-o-devices-and-filters">I/O Devices and Filters</a></li>
</ul>
</li>
<li><a class="reference internal" href="#control-flow">Control Flow</a><ul>
<li><a class="reference internal" href="#protocols">Protocols</a></li>
<li><a class="reference internal" href="#blocks-trials-and-lists">Blocks, Trials, and Lists</a></li>
<li><a class="reference internal" href="#task-systems">Task Systems</a></li>
<li><a class="reference internal" href="#if-if-else-and-while">If, If/Else, and While</a></li>
</ul>
</li>
<li><a class="reference internal" href="#visual-stimuli-and-display-management">Visual Stimuli and Display Management</a><ul>
<li><a class="reference internal" href="#declaring-stimuli">Declaring Stimuli</a></li>
<li><a class="reference internal" href="#queuing-and-dequeuing-stimuli">Queuing and Dequeuing Stimuli</a></li>
<li><a class="reference internal" href="#understanding-display-updates">Understanding Display Updates</a></li>
</ul>
</li>
<li><a class="reference internal" href="#advanced-tools-and-techniques">Advanced Tools and Techniques</a><ul>
<li><a class="reference internal" href="#variable-attached-actions">Variable-Attached Actions</a></li>
<li><a class="reference internal" href="#replicators">Replicators</a></li>
<li><a class="reference internal" href="#selection">Selection</a></li>
<li><a class="reference internal" href="#stimulus-animation">Stimulus Animation</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="data_analysis.html"
                        title="previous chapter">Analyzing Experimental Data</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../reference/index.html"
                        title="next chapter">Reference Manual</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="designing-an-experiment">
<h1>Designing an Experiment<a class="headerlink" href="#designing-an-experiment" title="Permalink to this headline">¶</a></h1>
<p>For both new and experienced MWorks users, designing an experiment can be a daunting task.  This guide attempts to break down and explain the elements of experimental design, both to help you better understand the working of existing experiments and to provide you with a mental framework for creating your own.</p>
<p><em>Note</em>: The examples included in and referred to by this guide all use <a class="reference internal" href="../mwel/index.html#mwel"><span class="std std-ref">MWEL</span></a>, which is recommended for new experiments.  However, the ideas and tools described here are equally applicable to XML-based experiments created or modified in MWEditor.  Any example files referred to by name can be found in the directory <code class="docutils literal notranslate"><span class="pre">/Library/Application</span> <span class="pre">Support/MWorks/Examples</span></code>.</p>
<div class="section" id="data-flow">
<h2>Data Flow<a class="headerlink" href="#data-flow" title="Permalink to this headline">¶</a></h2>
<div class="section" id="variables">
<h3>Variables<a class="headerlink" href="#variables" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="../components/variable.html#variable"><span class="std std-ref">Variables</span></a> play several essential roles in MWorks experiments.</p>
<p>Like the variables you may know from scripting or programming languages, MWorks variables associate names with values.  You can use them to store experiment parameters and record results.  Every <a class="reference internal" href="../components/assign_variable.html#assign-variable"><span class="std std-ref">assignment</span></a> to a variable generates an event that is recorded in the event file and can be <a class="reference internal" href="data_analysis.html#analyzing-experimental-data"><span class="std std-ref">extracted for analysis</span></a>.</p>
<p>In addition to their data storage role, variables also enable the flow of information between different MWorks <a class="reference internal" href="../components/index.html#components"><span class="std std-ref">components</span></a>.  This is described in more detail in the next section.</p>
</div>
<div class="section" id="i-o-devices-and-filters">
<h3>I/O Devices and Filters<a class="headerlink" href="#i-o-devices-and-filters" title="Permalink to this headline">¶</a></h3>
<p>MWorks interacts with the outside world via <a class="reference internal" href="../components/input_output.html#input-output"><span class="std std-ref">input/output</span></a> (I/O) devices.</p>
<p>Each time an input device receives new data, it assigns the relevant value(s) to one or more variables.  The target variables may be read directly by other parts of the experiment, or they can serve as inputs to <a class="reference internal" href="../components/filters.html#filters"><span class="std std-ref">filters</span></a>, which perform additional data processing and output new values (again via variables).</p>
<p>Conversely, when an experiment needs to send data to or perform an action in the outside world, it assigns values to one or more variables associated with an output device.  The output device watches those variables, and whenever one of them is assigned a new value, it takes appropriate action based on that value.</p>
<p>As an example, consider the typical flow of eye-tracking data in an MWorks experiment.  Raw eye positions are received from an eye tracker (e.g. an <a class="reference internal" href="../components/eyelink_device.html#eyelink-device"><span class="std std-ref">EyeLink</span></a>) and assigned to variables:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>var eye_h_raw = 0
var eye_v_raw = 0

iodevice/eyelink eyelink (
    pupil_lx = eye_h_raw
    pupil_ly = eye_v_raw
    tracker_ip = &#39;100.1.1.1&#39;
    tracking_dist = 1024
    data_interval = 1ms
    )
</pre></div>
</div>
<p>Next, the raw positions are used as input to an <a class="reference internal" href="../components/eye_calibrator.html#eye-calibrator"><span class="std std-ref">eye calibrator</span></a>, which applies a calibration and outputs the results:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>var eye_h_calibrated = 0
var eye_v_calibrated = 0

calibrator/standard_eye_calibrator eye_calibrator (
    eyeh_raw = eye_h_raw
    eyev_raw = eye_v_raw
    eyeh_calibrated = eye_h_calibrated
    eyev_calibrated = eye_v_calibrated
    )
</pre></div>
</div>
<p>Each component of the calibrated eye position then passes through a <a class="reference internal" href="../components/box_car_filter.html#box-car-filter"><span class="std std-ref">boxcar filter</span></a>, which computes a moving average of its input:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>var eye_h = 0
var eye_v = 0

filter/boxcar_filter_1d (
    in1 = eye_h_calibrated
    out1 = eye_h
    width_samples = 5
    )

filter/boxcar_filter_1d (
    in1 = eye_v_calibrated
    out1 = eye_v
    width_samples = 5
    )
</pre></div>
</div>
<p>Finally, the averaged eye coordinates serve as input to two additional components: a <a class="reference internal" href="../components/circular_fixation_point_stimulus.html#circular-fixation-point-stimulus"><span class="std std-ref">fixation point</span></a>, which reports whether the eye position lies within its target region, and an <a class="reference internal" href="../components/eye_monitor.html#eye-monitor"><span class="std std-ref">eye monitor</span></a>, which uses the coordinates to detect and report saccades:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>var eye_on_fixation_point = false

stimulus/circular_fixation_point fixation_point (
    trigger_watch_x = eye_h
    trigger_watch_y = eye_v
    trigger_width = 2
    trigger_flag = eye_on_fixation_point
    x_size = 0.4
    )

var eye_in_saccade = false

filter/basic_eye_monitor (
    eyeh_calibrated = eye_h
    eyev_calibrated = eye_v
    eye_state = eye_in_saccade
    width_samples = 5
    saccade_entry_speed = 60
    saccade_exit_speed = 20
    )
</pre></div>
</div>
<p>The final outputs of the eye-tracking pipeline are the values of the variables <code class="docutils literal notranslate"><span class="pre">eye_on_fixation_point</span></code> and <code class="docutils literal notranslate"><span class="pre">eye_in_saccade</span></code>.  These values, in turn, are used elsewhere in the experiment.  For example, they may be used in a <a class="reference internal" href="../components/conditional_transition.html#conditional-transition"><span class="std std-ref">conditional transition</span></a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>transition/conditional (
    target = &#39;Start fixation&#39;
    condition = eye_on_fixation_point and (not eye_in_saccade)
    )
</pre></div>
</div>
</div>
</div>
<div class="section" id="control-flow">
<h2>Control Flow<a class="headerlink" href="#control-flow" title="Permalink to this headline">¶</a></h2>
<div class="section" id="protocols">
<h3>Protocols<a class="headerlink" href="#protocols" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="../components/protocol.html#protocol"><span class="std std-ref">Protocols</span></a> encompass all the runtime logic of an MWorks experiment.  To “run” an experiment really means to execute one or more of its protocols.</p>
<p>A protocol is a container for other components.  Its child components can be simple <a class="reference internal" href="../components/actions.html#actions"><span class="std std-ref">actions</span></a>, or they can be other container components (<a class="reference internal" href="../components/block.html#block"><span class="std std-ref">blocks</span></a>, <a class="reference internal" href="../components/trial.html#trial"><span class="std std-ref">trials</span></a>, <a class="reference internal" href="../components/task_system.html#task-system"><span class="std std-ref">task systems</span></a>, etc.) with their own children.</p>
<p>The example experiment <code class="docutils literal notranslate"><span class="pre">HelloWorld.mwel</span></code> contains three protocols.  They range in complexity from extremely simple (a single action) to moderately complex (a task system and multiple trials).</p>
<p><em>Note</em>: The components of an experiment that are defined outside of any protocol (variables, I/O devices, visual stimuli, etc.) are shared by <em>all</em> protocols in the experiment.</p>
</div>
<div class="section" id="blocks-trials-and-lists">
<h3>Blocks, Trials, and Lists<a class="headerlink" href="#blocks-trials-and-lists" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="../components/block.html#block"><span class="std std-ref">Blocks</span></a>, <a class="reference internal" href="../components/trial.html#trial"><span class="std std-ref">trials</span></a>, and <a class="reference internal" href="../components/list.html#list"><span class="std std-ref">lists</span></a> provide high-level structure within a protocol.</p>
<p>Functionally, they are nearly identical.  All three are containers for other  components, and all support <a class="reference internal" href="#selection"><span class="std std-ref">selection</span></a>-based execution of their children.  They differ only in that entry to and exit from a block or trial is announced via a system variable (<a class="reference internal" href="../reference/sysvars.html#announceblock-var"><span class="std std-ref">#announceBlock</span></a> for blocks, <a class="reference internal" href="../reference/sysvars.html#announcetrial-var"><span class="std std-ref">#announceTrial</span></a> for trials), whereas no such announcement is made for lists.</p>
<p>Despite their suggestive names, MWorks makes no assumptions about the content and usage of these components.  Your experiment may employ them in any way that makes sense to you.</p>
</div>
<div class="section" id="task-systems">
<h3>Task Systems<a class="headerlink" href="#task-systems" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="../components/task_system.html#task-system"><span class="std std-ref">Task systems</span></a> are the most powerful and flexible tool that MWorks’ provides for managing the flow of control within an experiment.  The core execution logic of a protocol is typically implemented as a task system.</p>
<p>A task system is a form of <a class="reference external" href="https://en.wikipedia.org/wiki/Finite-state_machine">finite state machine</a>.  It is composed of one or more <a class="reference internal" href="../components/task_system_state.html#task-system-state"><span class="std std-ref">states</span></a>, each of which contains both <a class="reference internal" href="../components/actions.html#actions"><span class="std std-ref">actions</span></a> and <a class="reference internal" href="../components/transitions.html#transitions"><span class="std std-ref">transitions</span></a>.</p>
<p>Execution of a task system begins with its first state (the <em>start state</em>).  First, all of the state’s associated actions are executed.  Next, the transitions contained in the state are evaluated one by one, repeatedly if needed, until one of them succeeds.  Finally, execution of the task system transfers to the successful transition’s target state, and the process repeats.  The flow of control from state to state continues until a <a class="reference internal" href="../components/exit_task_system.html#exit-task-system"><span class="std std-ref">yield transition</span></a> succeeds, at which point execution of the task system ends.</p>
<p>As an example, consider the task system in <code class="docutils literal notranslate"><span class="pre">FindTheCircle.mwel</span></code>.  After displaying three colored squares on screen, the experiment enters a state called “Wait for selection”.  This state contains a <a class="reference internal" href="../components/start_timer.html#start-timer"><span class="std std-ref">Start Timer</span></a> action, followed by four transitions.  The first three transitions succeed when the subject selects the red, green, or blue square, respectively, while the fourth succeeds if the timer expires before any selection is made:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>state &#39;Wait for selection&#39; {
    start_timer (
        timer = selection_timer
        duration = selection_timeout
        )

    // Handle each possible selection
    goto (
        target = &#39;Red selected&#39;
        when = pointer_on_red_square
        )
    goto (
        target = &#39;Green selected&#39;
        when = pointer_on_green_square
        )
    goto (
        target = &#39;Blue selected&#39;
        when = pointer_on_blue_square
        )

    // If the timeout expires, go to state &quot;No selection&quot;
    goto (
        target = &#39;No selection&#39;
        when = timer_expired(selection_timer)
        )
}
</pre></div>
</div>
<p>If the subject selects a square, the task system proceeds to a state associated with the selected color.  This state records the selection in a variable, then chooses the next state based on whether the selection was correct.  For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>state &#39;Red selected&#39; {
    red_selected = true

    goto (
        target = &#39;Correct selection&#39;
        when = circle_x &lt; 0
        )
    goto (&#39;Incorrect selection&#39;)
}
</pre></div>
</div>
<p>Finally, the states “Correct selection”, “Incorrect selection”, and “No selection” each record the corresponding outcome and play an appropriate sound before proceeding, unconditionally, to the next state:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>state &#39;Correct selection&#39; {
    num_correct += 1
    play_sound (correct_sound)

    goto (&#39;Reveal circle&#39;)
}

state &#39;Incorrect selection&#39; {
    num_incorrect += 1
    play_sound (incorrect_sound)

    goto (&#39;Reveal circle&#39;)
}

state &#39;No selection&#39; {
    num_ignored += 1
    play_sound (ignored_sound)

    goto (&#39;End trial&#39;)
}
</pre></div>
</div>
</div>
<div class="section" id="if-if-else-and-while">
<h3>If, If/Else, and While<a class="headerlink" href="#if-if-else-and-while" title="Permalink to this headline">¶</a></h3>
<p>For the most part, <a class="reference internal" href="../components/actions.html#actions"><span class="std std-ref">actions</span></a> are the “atoms” of an experiment’s execution logic.  They perform a single task (e.g. <a class="reference internal" href="../components/start_io_device.html#start-io-device"><span class="std std-ref">starting an I/O device</span></a> or <a class="reference internal" href="../components/play_sound.html#play-sound"><span class="std std-ref">playing a sound</span></a>) and have no child components.  However, a few actions defy these constraints and serve as tools of control flow.</p>
<p>An <a class="reference internal" href="../components/conditionally_execute_actions_if.html#conditionally-execute-actions-if"><span class="std std-ref">if</span></a> action tests a condition expression.  If the expression evaluates to a true value (e.g. <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">true</span></code>), the <code class="docutils literal notranslate"><span class="pre">if</span></code> action then executues its child actions:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (red_selected) {
    report (&#39;Subject chose red&#39;)
}
</pre></div>
</div>
<p>An <a class="reference internal" href="../components/conditional_branching_if_else.html#conditional-branching-if-else"><span class="std std-ref">if_else</span></a> action encloses one or more <code class="docutils literal notranslate"><span class="pre">if</span></code> actions and at most one <a class="reference internal" href="../components/unconditionally_execute_actions_else.html#unconditionally-execute-actions-else"><span class="std std-ref">else</span></a> action.  It tests its <code class="docutils literal notranslate"><span class="pre">if</span></code> actions one by one and executes the first whose condition is true.  If all the conditions are false, the <code class="docutils literal notranslate"><span class="pre">if_else</span></code> will execute its <code class="docutils literal notranslate"><span class="pre">else</span></code> if present; otherwise, it does nothing:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if_else {
    if (red_selected) {
        report (&#39;Subject chose red&#39;)
    }
    if (green_selected) {
        report (&#39;Subject chose green&#39;)
    }
    if (blue_selected) {
        report (&#39;Subject chose blue&#39;)
    }
    else {
        report (&#39;Subject made no selection&#39;)
    }
}
</pre></div>
</div>
<p>Finally, a <a class="reference internal" href="../components/repeat_actions_while.html#repeat-actions-while"><span class="std std-ref">while</span></a> action is similar to an <code class="docutils literal notranslate"><span class="pre">if</span></code> in that it tests a condition and, if the condition is true, evaluates its child actions.  However, a <code class="docutils literal notranslate"><span class="pre">while</span></code> will repeat this process until its condition becomes false:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>index = 0
while (index &lt; num_images) {
    queue_stimulus (images[index])
    index += 1
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="visual-stimuli-and-display-management">
<h2>Visual Stimuli and Display Management<a class="headerlink" href="#visual-stimuli-and-display-management" title="Permalink to this headline">¶</a></h2>
<p>Throughout its history, MWorks’ primary users have been researchers studying vision.  Because of this, MWorks provides a rich set of <a class="reference internal" href="../components/stimuli.html#stimuli"><span class="std std-ref">visual stimuli</span></a> and tools for controlling their presentation on a display.</p>
<div class="section" id="declaring-stimuli">
<h3>Declaring Stimuli<a class="headerlink" href="#declaring-stimuli" title="Permalink to this headline">¶</a></h3>
<p>Like variables and I/O devices, the stimuli in an MWorks experiment are declared outside of all protocols (and, therefore, are available to <em>all</em> protocols):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>stimulus/circle red_circle (
    x_size = 2
    color = 1,0,0
    )
</pre></div>
</div>
<p>Stimuli can be declared individually, as above, or as members of a <a class="reference internal" href="../components/stimulus_group.html#stimulus-group"><span class="std std-ref">stimulus group</span></a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>stimulus_group circles {
    circle (
        x_size = 2
        x_position = -1
        color = 1,0,0  // Red
        )
    circle (
        x_size = 2
        x_position = 0
        color = 0,1,0  // Green
        )
    circle (
        x_size = 2
        x_position = 1
        color = 0,0,1  // Blue
        )
}
</pre></div>
</div>
<p>A stimulus declared individually can be referred to by its tag, e.g. <code class="docutils literal notranslate"><span class="pre">red_circle</span></code>.  A stimulus declared in a stimulus group can be referenced either via its own tag (if present) or by using the group’s tag and a zero-based index, e.g. <code class="docutils literal notranslate"><span class="pre">circles[0]</span></code>, <code class="docutils literal notranslate"><span class="pre">circles[2]</span></code>.</p>
</div>
<div class="section" id="queuing-and-dequeuing-stimuli">
<h3>Queuing and Dequeuing Stimuli<a class="headerlink" href="#queuing-and-dequeuing-stimuli" title="Permalink to this headline">¶</a></h3>
<p>To display a stimulus, you must first add it to the display queue via the <a class="reference internal" href="../components/queue_stimulus.html#queue-stimulus"><span class="std std-ref">Queue Stimulus</span></a> action:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>queue_stimulus (red_circle)
</pre></div>
</div>
<p>To display multiple stimuli simultaneously, queue the stimuli in <em>back-to-front</em> order.  For example, the following will result in the red circle being drawn first, followed by the green circle, followed by the blue circle.  Since the red and green circles overlap, and the green circle is queued <em>after</em> the red circle, the green circle will partly cover the red one.  Similarly, the blue circle will partly cover the green one:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>queue_stimulus (circles[0])
queue_stimulus (circles[1])
queue_stimulus (circles[2])
</pre></div>
</div>
<p>Changing the queuing order also changes the drawing order.  For example, the following will result in the green circle partly covering <em>both</em> the red and blue ones:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>queue_stimulus (circles[0])
queue_stimulus (circles[2])
queue_stimulus (circles[1])
</pre></div>
</div>
<p>When all the desired stimuli are queued, you commit your changes and trigger a display update with the <a class="reference internal" href="../components/update_stimulus_display.html#update-stimulus-display"><span class="std std-ref">Update Stimulus Display</span></a> action:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>update_display ()
</pre></div>
</div>
<p>To remove a stimulus from the display, you must first dequeue it with the <a class="reference internal" href="../components/dequeue_stimulus.html#dequeue-stimulus"><span class="std std-ref">Dequeue Stimulus</span></a> action.  As with queuing, multiple stimuli can be dequeued at the same time, and <code class="docutils literal notranslate"><span class="pre">update_display</span></code> commits your changes.  For example, the following will remove the red and blue circles from the display, but the green one will still be visible:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dequeue_stimulus (circles[0])
dequeue_stimulus (circles[2])
update_display ()
</pre></div>
</div>
<p>By combining queue and dequeue actions, you can both add and remove stimuli in a single display update:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// Remove green circle and restore red and blue ones
dequeue_stimulus (circles[1])
queue_stimulus (circles[0])
queue_stimulus (circles[2])
update_display ()
</pre></div>
</div>
</div>
<div class="section" id="understanding-display-updates">
<h3>Understanding Display Updates<a class="headerlink" href="#understanding-display-updates" title="Permalink to this headline">¶</a></h3>
<p>Computer displays typically update at a fixed <a class="reference external" href="https://en.wikipedia.org/wiki/Refresh_rate">refresh rate</a>.  For example, a display with a 60Hz refresh rate will redraw itself approximately once every 16.67 milliseconds.</p>
<p>To optimize graphics performance and avoid visual artifacts like <a class="reference external" href="https://en.wikipedia.org/wiki/Screen_tearing">screen tearing</a>, MWorks performs all stimulus-drawing operations in synchrony with the display’s refresh cycle.  Specifically, all drawing code executes on a dedicated operating system <a class="reference external" href="https://en.wikipedia.org/wiki/Thread_(computing)">thread</a>, independent of the thread on which the running protocol executes, and rendered frames are transferred to the display hardware only during the <a class="reference external" href="https://en.wikipedia.org/wiki/Vertical_blanking_interval">vertical blanking interval</a>, which occurs once per refresh period.</p>
<p>Contrary to what you might expect, the completion of an <a class="reference internal" href="../components/update_stimulus_display.html#update-stimulus-display"><span class="std std-ref">Update Stimulus Display</span></a> action does <em>not</em> signal that the display has actually been updated.  Rather, it indicates only that all stimulus drawing commands have been submitted to the graphics hardware, and that their effects will become visible during the next refresh of the display (which should begin less than one refresh period in the future).</p>
<p>Every time MWorks updates the display, it announces the update via the <a class="reference internal" href="../reference/sysvars.html#stimdisplayupdate-var"><span class="std std-ref">#stimDisplayUpdate</span></a> system variable.  As with <code class="docutils literal notranslate"><span class="pre">update_display</span></code>, this announcement is made <em>before</em> the display is actually updated.  The time stamp on the announcement event is the operating system’s best guess for when the rendered frame will start to appear on the display.  (More precisely, it is the operating system’s estimate, based on past data, of when the next <a class="reference external" href="https://en.wikipedia.org/wiki/Vertical_blank_interrupt">vertical blank interrupt</a> will occur.  The display should begin redrawing itself shortly afterward.)</p>
<p>If you need access to this predicted time within your experiment, set the <code class="docutils literal notranslate"><span class="pre">predicted_output_time</span></code> parameter of <code class="docutils literal notranslate"><span class="pre">update_display</span></code> to the name of a variable in which to store the value:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>update_display(predicted_output_time = my_var)
</pre></div>
</div>
<p>Regardless of when or how you use this time stamp, remember that it is only a <em>prediction</em> of when a future display update will begin.  If you need to know precisely when a particular stimulus appears on screen, you must measure its onset time yourself (e.g. with a photodiode attached to the display).</p>
</div>
</div>
<div class="section" id="advanced-tools-and-techniques">
<h2>Advanced Tools and Techniques<a class="headerlink" href="#advanced-tools-and-techniques" title="Permalink to this headline">¶</a></h2>
<div class="section" id="variable-attached-actions">
<h3>Variable-Attached Actions<a class="headerlink" href="#variable-attached-actions" title="Permalink to this headline">¶</a></h3>
<p>Although <a class="reference internal" href="../components/actions.html#actions"><span class="std std-ref">actions</span></a> normally reside inside a <a class="reference internal" href="../components/protocol.html#protocol"><span class="std std-ref">protocol</span></a>, you can also attach them to <a class="reference internal" href="../components/variable.html#variable"><span class="std std-ref">variables</span></a>.</p>
<p>Actions that are attached to a variable execute every time the variable is assigned a value.  For example, by attaching a <a class="reference internal" href="../components/report_message.html#report-message"><span class="std std-ref">report</span></a> action to a variable, you can log a message every time the variable’s value is set:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>var x (0) {
    report (&#39;x = $x&#39;)
}
</pre></div>
</div>
<p>Variable-attached actions will execute <em>even if no protocol is running</em>.  If you load an experiment containing the above declarion of <code class="docutils literal notranslate"><span class="pre">x</span></code> and, before pressing the start button, assign the value 7 to <code class="docutils literal notranslate"><span class="pre">x</span></code> via MWClient’s variables window, you will see the message <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">7</span></code> in the console.</p>
<p>Be aware that attaching an <a class="reference internal" href="../components/assign_variable.html#assign-variable"><span class="std std-ref">assignment</span></a> to the assignment’s target variable will result in <a class="reference external" href="https://en.wikipedia.org/wiki/Deadlock">deadlock</a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>var y (0) {
    // Don&#39;t do this!
    y += 1
}
</pre></div>
</div>
<p>Variable-attached actions are a powerful tool that enable a form of <a class="reference external" href="https://en.wikipedia.org/wiki/Event-driven_programming">event-driven programming</a> within  MWorks experiments.  They can even play a role similar to <a class="reference external" href="https://en.wikipedia.org/wiki/Subroutine">subroutines</a>, where assignment to the parent variable “calls” the routine.  (However, MWEL <a class="reference internal" href="../mwel/index.html#statement-macros"><span class="std std-ref">statement macros</span></a> are better suited to this task.)</p>
</div>
<div class="section" id="replicators">
<h3>Replicators<a class="headerlink" href="#replicators" title="Permalink to this headline">¶</a></h3>
<p><em>Coming soon!</em></p>
</div>
<div class="section" id="selection">
<span id="id1"></span><h3>Selection<a class="headerlink" href="#selection" title="Permalink to this headline">¶</a></h3>
<p><em>Coming soon!</em></p>
</div>
<div class="section" id="stimulus-animation">
<h3>Stimulus Animation<a class="headerlink" href="#stimulus-animation" title="Permalink to this headline">¶</a></h3>
<p><em>Coming soon!</em></p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../reference/index.html" title="Reference Manual"
             >next</a> |</li>
        <li class="right" >
          <a href="data_analysis.html" title="Analyzing Experimental Data"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">MWorks 0.8.dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >User Guide</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016-2018, The MWorks Project.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.2.
    </div>
  </body>
</html>